# UndirectedGeneratingSets.gap

# These programs are adapted from algorithms in Appendix A of the following masters thesis:
#	Brandon Fuller
#	"Finding CCA groups and graphs algorithmically"
#	(University of Lethbridge, 2017)
#	 http://hdl.handle.net/10133/4996 

IsIrredundant := function(G,S)
	# return true if S is irredundant, which means that no element of S is in 
	# the subgroup generated by the others
	return ForAll(S, s -> not(s in Subgroup(G, Filtered(S, t -> (t <> s)))));
end;

IrredGenSetsFromAvailable := function(G, GensRequired, GensAvailable)
	# return a list of the irredundant generating sets of G that contain the set GensRequired
	# and are contained in the union of GensRequired and GensAvailable
	# (It is assumed that GensRequired is irredundant)
	local GenSets, i, S;
	GenSets := []; # GenSets is a list of the generating sets that have been constructed so far
	if Subgroup(G, GensRequired) = G then 
		# do not add any additional generators
		return [AsSortedList(GensRequired)];
	else
		# for each available generator, recursively find all irredundant generating sets 
		# that can be obtained by adding it (and perhaps later elements of GensAvailable) 
		# to GensRequired
		for i in [1..Length(GensAvailable)] do
			S := Concatenation(GensRequired, [GensAvailable[i]]);
			if IsIrredundant(G,S) then
				Append(GenSets, IrredGenSetsFromAvailable(G, S, 
						GensAvailable{[i+1 .. Length(GensAvailable)]}));
			fi;
		od;
	fi;
	return GenSets;
end;

Inversed := function(S)
	# return a list of all sets that can be obtained by replacing some (or all or none)
	# of the elements of S by their inverses
	return Cartesian( List(S, s -> AsSSortedList([s, s^-1])));
end;			

IsInListUpToUndirAut := function(T,GenSets)
	# return true if T is equal to some element of the list GenSets, after applying an 
	# automorphism of G, reordering, and/or replacing some elements by their inverses.
	# (We assume that each element of GenSets generates Group(T).)
	local G, S, perm, permS, permSpm;
	if T = [] then 
		# the empty set is a special case, because Group([]) is not well-defined
		return (T in GenSets);
	fi;
	G := Group(T);
  	for S in GenSets do
  		# we will test whether T is equal to S (up to reordering, automorphisms and inverses)
  		# It is time-consuming to rigorously check whether there is an automorphism 
  		# taking T to S, so we apply some simple tests to eliminate most cases.
  		if Length(S) = Length(T) then # cannot be equal unless same length
  			# check sets obtained by permuting the elements of S
			for perm in SymmetricGroup( Length(T) ) do
  				permS := Permuted(S, perm);
  				# cannot be equal unless orders of corresponding elements are equal:
  				if List(permS, s -> Order(s)) = List(T, t -> Order(t)) then 
  					# check sets obtained by inverting some elements of permS
  					for permSpm in Inversed(permS) do
  						# cannot be equal unless orders of corresponding products are equal:
  						if ForAll( Cartesian([1..Length(permSpm)],[1..Length(permSpm)]),
  								x -> Order(permSpm[x[1]]*permSpm[x[2]]) = Order(T[x[1]]*T[x[2]]))
  						then
  							# can GAP find an automorphism that takes T to permSpm?
  	    					if (GroupHomomorphismByImages( G, G, T, permSpm ) <> fail) then
    							return true;
    						fi;
    					fi;
    				od;
    			fi;
    		od;
    	fi;
  	od;
	return false;
end;

CyclicRepresentatives := function(G)
	# return a list containing one generator (the smallest) of each cyclic subgroup of G
	return AsSSortedList( List(G, g -> Minimum( List( PrimeResidues(Order(g)), j -> g^j ))) );
end;

IrredUndirGenSetsUpToAut := function(G)
	# return a list of the irredundant generating sets of G, where two sets are 
	# considered equal if one can be obtained from the other by applying an 
	# automorphism of G and/or replacing some elements by their inverses
	local GenSets, S, T;	
	GenSets := [];
	for S in IrredGenSetsFromAvailable(G, [], CyclicRepresentatives(G)) do
		# construct all generating sets that can be obtained by replacing
		# elements of S by a power that generates the same cyclic subgroup.
		# (To reduce duplication, we only allow powers that are <= half the order of s, 
		# because we are not distinguishing between an element and its inverse.) 
		for T in Cartesian( List(S, s -> List( 
					Filtered(PrimeResidues(Order(s)), i -> (i <= QuoInt(Order(s),2))),
					j -> s^j )))
		do
			# add T to the list of generating sets if it is not a duplicate:
			if not(IsInListUpToUndirAut(T,GenSets)) then			
				Add(GenSets, T);
			fi;
		od;
	od;
	return GenSets;
end;

# This is free and unencumbered software released into the public domain.
# 
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
# 
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
# 
# For more information, please refer to <http://unlicense.org/>
